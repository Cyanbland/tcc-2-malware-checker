#pragma once
#include "Hooks.hpp"
#include "Global.hpp"
#include "Logging.hpp"

PDRIVER_DISPATCH o_FltMgrIoDispatcher = nullptr;

NTSTATUS hk_FltMgrIoDispatcher(PDEVICE_OBJECT Device, PIRP Irp)
{
	PIO_STACK_LOCATION IoStackLocation = IoGetCurrentIrpStackLocation(Irp);

	// Make sure IoStackLocation is valid
	if (!IoStackLocation)
		goto EXIT;

	// If the previous mode is KernelMode we just allow the operation
	if (ExGetPreviousMode() == KernelMode)
		goto EXIT;


	//if (IoStackLocation->MajorFunction == IRP_MJ_WRITE)
	//{
	//	PFILE_OBJECT FileObject = IoStackLocation->FileObject;

	//	// Make sure pointers are valid
	//	if (!FileObject || !FileObject->FileName.Buffer)
	//		goto EXIT;	
	//	
	//	// Check if the target file is our log file
	//	if (wcsstr(FileObject->FileName.Buffer, L"FltMgrHookKD.log"))
	//	{
	//		PUNICODE_STRING ProcessName = nullptr;

	//		if (!NT_SUCCESS(SeLocateProcessImageName(PsGetCurrentProcess(), &ProcessName)))
	//			goto EXIT;

	//		if (ProcessName && ProcessName->Buffer)
	//		{
	//			// Allow the operation if the requesting process is a whiteslited process
	//			if (Global::IsAttachedProcessWhitelisted())
	//			{
	//				ExFreePool(ProcessName);
	//				goto EXIT;
	//			}
	//				

	//			LOGGING_LOG_DEBUG("Process => (%S) tried to write on FltMgrHookKD.log", ProcessName->Buffer);
	//		}
	//			

	//		Irp->IoStatus.Information = 5;
	//		Irp->IoStatus.Status = STATUS_ACCESS_DENIED;

	//		// As we are not calling the original I/O dispatcher, we need to take care of possible leaks, in this case we dereference the object counter from FileObject
	//		ObDereferenceObject(FileObject);

	//		ExFreePool(ProcessName);

	//		return STATUS_ACCESS_DENIED;
	//	}
	//}
	if (IoStackLocation->MajorFunction == IRP_MJ_SET_INFORMATION)
	{
		ULONG FileInformationClass = IoStackLocation->Parameters.SetFile.FileInformationClass;

		switch (FileInformationClass)
		{
		case FileRenameInformationBypassAccessCheck:
		case FileRenameInformation:
		case FileRenameInformationEx:
		case FileRenameInformationExBypassAccessCheck:
			PFILE_OBJECT FileObject = IoStackLocation->Parameters.SetFile.FileObject;

			if (!FileObject || !FileObject->FileName.Buffer)
				goto EXIT;

			PUNICODE_STRING ProcessName = nullptr;

			if (!NT_SUCCESS(SeLocateProcessImageName(PsGetCurrentProcess(), &ProcessName)))
				goto EXIT;

			if (!ProcessName || !ProcessName->Buffer)
			{
				ExFreePool(ProcessName);
				goto EXIT;
			}
				

			LOGGING_LOG_DEBUG("Process => (%S) renamed file => (%S)", ProcessName->Buffer, FileObject->FileName.Buffer);

			ExFreePool(ProcessName);

			break;
		}
	}

EXIT:
	return o_FltMgrIoDispatcher(Device, Irp);
}


VOID Hooks::Initialize()
{
	HookUtils::HookIoDispatcher(L"\\FileSystem\\FltMgr", IRP_MJ_SET_INFORMATION, hk_FltMgrIoDispatcher, (PVOID*)&o_FltMgrIoDispatcher);
	//HookUtils::HookIoDispatcher(L"\\FileSystem\\FltMgr", IRP_MJ_WRITE, hk_FltMgrIoDispatcher, (PVOID*)&o_FltMgrIoDispatcher);
}

VOID Hooks::Deinitialize()
{
	HookUtils::UnhookIoDispatcher(L"\\FileSystem\\FltMgr", IRP_MJ_SET_INFORMATION, o_FltMgrIoDispatcher);
	//HookUtils::UnhookIoDispatcher(L"\\FileSystem\\FltMgr", IRP_MJ_WRITE, o_FltMgrIoDispatcher);
}
