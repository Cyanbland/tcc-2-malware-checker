using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using PacketDotNet;
using SharpPcap;

namespace DynamicAnalysisAgent
{
    internal class NetworkSnifferModule
    {
        private List<string> detectedURLs = new List<string>();
        private List<string> detectedIPs = new List<string>();
        private ICaptureDevice device;

        public NetworkSnifferModule(int deviceIndex)
        {
            var devices = CaptureDeviceList.Instance;
            if (deviceIndex < 0 || deviceIndex >= devices.Count)
            {
                throw new ArgumentException("Invalid device index.");
            }

            device = devices[deviceIndex];
        }

        public void Start()
        {
            if (device == null)
            {
                throw new InvalidOperationException("No capture device selected.");
            }


            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrival);
            device.Open(DeviceModes.Promiscuous);
            device.StartCapture();
        }

        public void Stop()
        {
            if (device != null && device.Started)
            {
                device.StopCapture();
                device.Close();
            }
        }

        static string ExtractDomain(string url)
        {
            var match = Regex.Match(url, @"^(?:https?:\/\/)?(?:www\.)?([^\/\s]+)");
            return match.Success ? match.Groups[1].Value.Replace("\r", "") : null;
        }

        private void device_OnPacketArrival(object sender, PacketCapture pc)
        {
            var time = pc.Header.Timeval.Date;
            var len = pc.Data.Length;
            var rawPacket = pc.GetPacket();

            var packet = Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);


            var tcpPacket = packet.Extract<TcpPacket>();
            if (tcpPacket != null)
            {
                var ipPacket = (IPPacket)tcpPacket.ParentPacket;
                IPAddress srcIp = ipPacket.SourceAddress;
                IPAddress dstIp = ipPacket.DestinationAddress;
                
                int srcPort = tcpPacket.SourcePort;
                int dstPort = tcpPacket.DestinationPort;

                var data = tcpPacket.PayloadData;
                string dataStr = System.Text.Encoding.UTF8.GetString(data);


                var urlMatches = Regex.Matches(dataStr, @"http[s]?:\/\/[^\s]+");

                foreach (Match match in urlMatches)
                {
                    var url = match.Value;
                    string baseDomain = ExtractDomain(url);

                    if (baseDomain != null && !detectedURLs.Contains(baseDomain))
                    {
                        detectedURLs.Add(baseDomain);
                        Console.WriteLine($"Detected URL: {baseDomain}");
                    }
                }

                var ipMatches = Regex.Matches(dataStr, @"\b(?:\d{1,3}\.){3}\d{1,3}\b");

                foreach (Match match in ipMatches)
                {
                    var ip = match.Value;
                    if (!detectedIPs.Contains(ip))
                    {
                        detectedIPs.Add(ip);
                        Debug.WriteLine($"Detected IP: {ip}");
                    }
                }

                if (!detectedIPs.Contains((srcIp.ToString())) && !IsLocalIPAddress(srcIp))
                {
                    detectedIPs.Add((srcIp.ToString()));
                    Debug.WriteLine($"Detected IP: {srcIp}");
                }

                if (!detectedIPs.Contains((dstIp.ToString())) && !IsLocalIPAddress(srcIp))
                {
                    detectedIPs.Add((dstIp.ToString()));
                    Debug.WriteLine($"Detected IP: {dstIp}");
                }

            }

            var udpPacket = packet.Extract<UdpPacket>();

            if (udpPacket != null)
            {
                Console.WriteLine("Original UDP packet: " + udpPacket.ToString());

                var data = udpPacket.PayloadData;
                string dataStr = System.Text.Encoding.UTF8.GetString(data);

                var urlMatches = Regex.Matches(dataStr, @"http[s]?:\/\/[^\s]+");

                foreach (Match match in urlMatches)
                {
                    var url = match.Value;
                    if (!detectedURLs.Contains(url))
                    {
                        detectedURLs.Add(url);
                        Debug.WriteLine($"Detected URL: {url}");
                    }
                }

                var ipMatches = Regex.Matches(dataStr, @"\b(?:\d{1,3}\.){3}\d{1,3}\b");

                foreach (Match match in ipMatches)
                {
                    var ip = match.Value;
                    if (!detectedIPs.Contains(ip))
                    {
                        detectedIPs.Add(ip);
                        Debug.WriteLine($"Detected IP: {ip}");
                    }
                }
            }

        }

        private bool IsLocalIPAddress(IPAddress ipAddress)
        {
            var localIPRanges = new[]
            {
            new { Start = IPAddress.Parse("10.0.0.0"), End = IPAddress.Parse("10.255.255.255") },
            new { Start = IPAddress.Parse("172.16.0.0"), End = IPAddress.Parse("172.31.255.255") },
            new { Start = IPAddress.Parse("192.168.0.0"), End = IPAddress.Parse("192.168.255.255") },
            new { Start = IPAddress.Parse("127.0.0.0"), End = IPAddress.Parse("127.255.255.255") },
        };

            foreach (var range in localIPRanges)
            {
                if (IsIPAddressInRange(ipAddress, range.Start, range.End))
                {
                    return true;
                }
            }

            return false;
        }

        private static bool IsIPAddressInRange(IPAddress ipAddress, IPAddress startIPAddress, IPAddress endIPAddress)
        {
            byte[] startBytes = startIPAddress.GetAddressBytes();
            byte[] endBytes = endIPAddress.GetAddressBytes();
            byte[] ipBytes = ipAddress.GetAddressBytes();

            bool greaterThanOrEqualStart = true;
            bool lessThanOrEqualEnd = true;

            for (int i = 0; i < startBytes.Length && (greaterThanOrEqualStart || lessThanOrEqualEnd); i++)
            {
                if (ipBytes[i] < startBytes[i])
                    greaterThanOrEqualStart = false;
                if (ipBytes[i] > endBytes[i])
                    lessThanOrEqualEnd = false;
            }

            return greaterThanOrEqualStart && lessThanOrEqualEnd;
        }

        public List<string> GetDetectedURLs()
        {
            return detectedURLs;
        }

        public List<string> GetDetectedIPs()
        {
            return detectedIPs;
        }
    }
}
