import { ConflictException, ForbiddenException, Injectable, PreconditionFailedException } from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { ConfigurationService } from '../configuration/configuration.service';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { PrismaService } from '../prisma/prisma.service';
import { AgentsWebSocketServer } from './websocket';

@Injectable()
export class AgentService {
    private ws: AgentsWebSocketServer;

    constructor(private configuration: ConfigurationService, private prisma: PrismaService) {
        this.initializeWebSocketService();
    }

    async initializeWebSocketService()
    {
        this.ws = new AgentsWebSocketServer(3335, this);
    }

    async generateEnrollmentToken(email: string, fileId: string) {       
        const token = `${email}#${fileId}#${uuidv4()}`;

        const newUserConfiguration = await this.configuration.updateEnrollmentToken(email, token)

        return { token };
    }

    async validateEnrollmentToken(token: string) {
        try {
            const token_data = String(token).split("#")
            const email = token_data[0]
            const fileId = token_data[1]

            const configuration = await this.configuration.getMyConfig(email)

            
            if (!configuration) {
                throw new PreconditionFailedException("Invalid Token!")
            }
            
            if (token !== configuration.enrollmentToken) {
                throw new PreconditionFailedException("Enrollment Token is incorrect!")
            }
            
            const existentAgentData = await this.prisma.agentData.findUnique({
                where: {
                    fileId
                }
            })

            // delete previous data
            if (existentAgentData) {
                const deletedAgentData = await this.prisma.agentData.delete({
                    where: {
                        fileId
                    }
                })
            }

            const newAgentData = await this.prisma.agentData.create({
                data: {
                    fileId
                }
            })

            // generate a new enrollment token to make the current one invalid
            this.generateEnrollmentToken(email, fileId)

            return { success: true }
        }
        catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                // "The record searched for in the where condition ({model_name}.{argument_name} = {argument_value}) does not exist"
                if (error.code === 'P2001') {
                    throw new ForbiddenException("Enrollment Token is incorrect")
                }
                if (error.code === 'P2002') {
                    console.log(error)
                    throw new ConflictException("Enrollment Token was already used. Please generate a new one!")
                }
            }

            throw error;
        }
    }

    async updateAgentDataLogs(agentFileId: string, logs: string[], log_type: string, isURL: boolean = false) {
        switch(log_type) {
            case "NetworkSniffing": {
                const currentAgentData = await this.prisma.agentData.findUnique({
                    where: {
                        fileId: agentFileId
                    }
                })
                
                if (isURL) {
                    const allUrlLogs = currentAgentData.networkSniffingURLs.concat(logs)
    
                    const updatedAgentData = await this.prisma.agentData.update({
                        where: {
                            fileId: agentFileId
                        },
                        data: {
                            networkSniffingURLs: allUrlLogs
                        }
                    })
                    return updatedAgentData
                }
                else {
                    const allIPLogs = currentAgentData.networkSniffingIPs.concat(logs)

                    const updatedAgentData = await this.prisma.agentData.update({
                        where: {
                            fileId: agentFileId
                        },
                        data: {
                            networkSniffingIPs: allIPLogs
                        }
                    })
                    return updatedAgentData
                }
            }
                
            case "RansomwareDetection": {
                const currentAgentData = await this.prisma.agentData.findUnique({
                    where: {
                        fileId: agentFileId
                    }
                })
                
                const allLogs = currentAgentData.ransomwareDetectionData.concat(logs)
                console.log(allLogs)

                const updatedAgentData = await this.prisma.agentData.update({
                    where: {
                        fileId: agentFileId
                    },
                    data: {
                        ransomwareDetectionData: allLogs
                    }
                })

                return updatedAgentData
            }
            default:
                console.log('Unknown log type:', log_type);
        }
    }
}
