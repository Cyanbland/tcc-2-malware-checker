import { ConflictException, ForbiddenException, Injectable, PreconditionFailedException } from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { ConfigurationService } from '../configuration/configuration.service';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class AgentService {
    constructor(private configuration: ConfigurationService, private prisma: PrismaService) {}

    async generateEnrollmentToken(email: string, fileId: string) {       
        const token = `${email}#${fileId}#${uuidv4()}`;

        const newUserConfiguration = await this.configuration.updateEnrollmentToken(email, token)

        return { token };
    }

    async validateEnrollmentToken(token: string) {
        try {
            const token_data = String(token).split("#")
            const email = token_data[0]
            const fileId = token_data[1]

            const configuration = await this.configuration.getMyConfig(email)

            
            if (!configuration) {
                throw new PreconditionFailedException("Invalid Token!")
            }
            
            if (token !== configuration.enrollmentToken) {
                throw new PreconditionFailedException("Enrollment Token is incorrect!")
            }
            
            const newAgentData = await this.prisma.agentData.create({
                data: {
                    fileId
                }
            })

            return { success: true }
        }
        catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                // "The record searched for in the where condition ({model_name}.{argument_name} = {argument_value}) does not exist"
                if (error.code === 'P2001') {
                    throw new ForbiddenException("Enrollment Token is incorrect")
                }
                if (error.code === 'P2002') {
                    throw new ConflictException("Enrollment Token was already used. Please generate a new one!")
                }
            }

            throw error;
        }
    }

    async updateAgentDataLogs(agentFileId: string, logs: string[], log_type: string) {
        switch(log_type) {
            case "NetworkSniffing": {
                const currentAgentData = await this.prisma.agentData.findUnique({
                    where: {
                        fileId: agentFileId
                    }
                })
                
                currentAgentData.networkSniffingData.push(...logs)

                const updatedAgentData = await this.prisma.agentData.update({
                    where: {
                        fileId: agentFileId
                    },
                    data: {
                        networkSniffingData: currentAgentData.networkSniffingData
                    }
                })

                return updatedAgentData
            }
                
            case "RansomwareDetection": {
                const currentAgentData = await this.prisma.agentData.findUnique({
                    where: {
                        fileId: agentFileId
                    }
                })
                
                currentAgentData.ransomwareDetectionData.push(...logs)

                const updatedAgentData = await this.prisma.agentData.update({
                    where: {
                        fileId: agentFileId
                    },
                    data: {
                        ransomwareDetectionData: currentAgentData.ransomwareDetectionData
                    }
                })

                return updatedAgentData
            }
            default:
                console.log('Unknown log type:', log_type);
        }
    }
}
