import { BadRequestException, ConflictException, Injectable, NotFoundException, OnModuleInit, PreconditionFailedException } from '@nestjs/common'
import { PrismaService } from '../prisma/prisma.service'
import { existsSync, readdirSync, statSync } from 'fs'
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library'
import {basename, resolve} from 'path'
import { YaraRuleService } from '../yara_rule/yara_rule.service'

@Injectable()
export class YaraSourceService implements OnModuleInit {
    async onModuleInit() {
        const yaraGithubSourceExists = await this.prisma.yaraRuleSource.findUnique({
            where: {
                name: "YARA Main Github"
            }
        })

        const alienvaultlabsGithubSourceExists = await this.prisma.yaraRuleSource.findUnique({
            where: {
                name: "AlienVault Labs Malware Analysis"
            }
        })

        const anyRunYaraGithubSourceExists = await this.prisma.yaraRuleSource.findUnique({
            where: {
                name: "AnyRun YARA Rules"
            }
        })

        const deadbitsYaraGithubSourceExists = await this.prisma.yaraRuleSource.findUnique({
            where: {
                name: "Deadbits YARA Rules"
            }
        })

        const loginsoftMaldocSourceExists = await this.prisma.yaraRuleSource.findUnique({
            where: {
                name: "Loginsoft Malware Documents Research - YARA Rules"
            }
        })

        const elasticYaraSourceExists = await this.prisma.yaraRuleSource.findUnique({
            where: {
                name: "Elastic Security YARA Rules"
            }
        })
        
        if (yaraGithubSourceExists === null) {
            console.log("Generating YaraGithubSource")
            const yaraGithubSource = await this.createYaraSource(this.yaraGithubDir, "YARA Main Github", "https://github.com/Yara-Rules/rules")
            const yaraRulesFromYaraGithubSource = await this.addRulesToSource(this.yaraGithubDir, yaraGithubSource.id)
            console.log("Finished generating YaraGithubSource")
        }

        if (alienvaultlabsGithubSourceExists === null) {
            console.log("Generating AlienvaultGithubSource")
            const AlienvaultGithubSource = await this.createYaraSource(this.alienVaultLabsDir, "AlienVault Labs Malware Analysis", "https://github.com/AlienVault-Labs/AlienVaultLabs/tree/master/malware_analysis")
            const yaraRulesFromAlienvaultLabsGithubSource = await this.addRulesToSource(this.alienVaultLabsDir, AlienvaultGithubSource.id)
            console.log("Finished generating AlienvaultGithubSource")
        }

        if (anyRunYaraGithubSourceExists === null) {
            console.log("Generating AnyRunYaraGithubSource")
            const anyRunYaraGithubSource = await this.createYaraSource(this.anyRunYaraDir, "AnyRun YARA Rules", "https://github.com/anyrun/YARA")
            const yaraRulesFromAnyRunGithubSource = await this.addRulesToSource(this.anyRunYaraDir, anyRunYaraGithubSource.id)
            console.log("Finished generating AnyRunYaraGithubSource")
        }

        if (deadbitsYaraGithubSourceExists === null) {
            console.log("Generating deadbitsYaraGithubSource")
            const deadbitsYaraGithubSource = await this.createYaraSource(this.deadbitsYaraDir, "Deadbits YARA Rules", "https://github.com/deadbits/yara-rules")
            const yaraRulesFromdeadbitsYaraGithubSource = await this.addRulesToSource(this.deadbitsYaraDir, deadbitsYaraGithubSource.id)
            console.log("Finished generating deadbitsYaraGithubSource")
        }

        if (loginsoftMaldocSourceExists === null) {
            console.log("Generating loginsoftMaldocSource")
            const loginsoftMaldocSource = await this.createYaraSource(this.loginsoftMaldocYaraDir, "Loginsoft Malware Documents Research - YARA Rules", "https://research.loginsoft.com/yara-rules")
            const yaraRulesFromloginsoftMaldocSource = await this.addRulesToSource(this.loginsoftMaldocYaraDir, loginsoftMaldocSource.id)
            console.log("Finished generating loginsoftMaldocSource")
        }

        if (elasticYaraSourceExists === null) {
            console.log("Generating elasticYaraSource")
            const elasticYaraSource = await this.createYaraSource(this.loginsoftMaldocYaraDir, "Elastic Security YARA Rules", "https://github.com/elastic/protections-artifacts/tree/main/yara")
            const yaraRulesFromelasticYaraSource = await this.addRulesToSource(this.loginsoftMaldocYaraDir, elasticYaraSource.id)
            console.log("Finished generating elasticYaraSource")
        }
    }
     
    constructor(private prisma: PrismaService, private yaraService: YaraRuleService) {}
     
    private yaraGithubDir = resolve(__dirname, '../../yara_sources/rules-master')
    private alienVaultLabsDir = resolve(__dirname, '../../yara_sources/alienvaultlabs')
    private anyRunYaraDir = resolve(__dirname, '../../yara_sources/anyrun_yara')
    private deadbitsYaraDir = resolve(__dirname, '../../yara_sources/deadbits_yara')
    private loginsoftMaldocYaraDir = resolve(__dirname, '../../yara_sources/loginsoft-maldoc-research')
    
    async createYaraSource(pathToRules: string, name: string, referenceUrl: string) {
        if (!existsSync(pathToRules)) {
            throw new NotFoundException(`Yara Github not found at ${pathToRules}`)
        }
        
        try {
            let data = {
                name,
                referenceUrl
            }
            
            return await this.prisma.yaraRuleSource.create({ data })
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new BadRequestException(error.message)
            }
        }
    }
    

    async addRulesToSource(path: string, sourceId: number) {
        // create a Yara Rule for each .yar file 
        const yaraExt = "yar"
        
        try {
            const yaraRules = this.getAllFilesWithExtension(path, yaraExt)
            
            yaraRules.forEach(file => {
                let fileName = basename(file)
                this.yaraService.createYaraRule(fileName, file, sourceId)
            })
            
            return await this.prisma.yaraRule.findMany({
                where: {
                    sourceId
                }
            })
        }
        
        catch(error) {
            throw new NotFoundException(error.message)
        }
    }

    
    getAllFilesWithExtension(directoryPath, extension, fileList = []) {
        const files = readdirSync(directoryPath)
        
        files.forEach(file => {
            const filePath = resolve(directoryPath, file)
            const fileStat = statSync(filePath)
            
            if (fileStat.isDirectory()) {
                this.getAllFilesWithExtension(filePath, extension, fileList)
            } else if (filePath.endsWith(`.${extension}`)) {
                fileList.push(filePath)
            }
        })
        
        return fileList
    }
    
    async subscribeUserToYaraSource(email: string, sourceId: number) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            
            const source = await this.prisma.yaraRuleSource.findUnique({
                where: {
                    id: sourceId
                }
            })
            
            if (!source) {
                throw new NotFoundException("Source not found!")
            }
            
            const currentUserYaraSource = await this.prisma.yaraRuleSourcesOnUsers.findFirst({
                where: {
                    sourceId,
                    userId: user.id
                }
            })
            
            if (currentUserYaraSource) {
                throw new ConflictException("User is already subscribed to this YARA Source")
            }
            
            return this.prisma.yaraRuleSourcesOnUsers.create({
                data: {
                    sourceId,
                    userId: user.id
                }
            })
        }
        
        catch(error) {
            throw error
        }
    }
    
    async unsubscribeUserToYaraSource(email: string, sourceId: number) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            
            const source = await this.prisma.yaraRuleSource.findUnique({
                where: {
                    id: sourceId
                }
            })
            
            if (!source) {
                throw new NotFoundException("Source not found!")
            }
            
            const currentUserYaraSource = await this.prisma.yaraRuleSourcesOnUsers.findFirst({
                where: {
                    sourceId,
                    userId: user.id
                }
            })
            
            if (!currentUserYaraSource) {
                throw new PreconditionFailedException("User is not subscribed to this YARA Source")
            }
            
            return this.prisma.yaraRuleSourcesOnUsers.delete({
                where: {
                    userId_sourceId: {
                        userId: user.id,
                        sourceId
                    }
                }
            })
        }
        
        catch(error) {
            throw error
        }
    }
    
    async listSubscribedYaraSources(email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                },
                include: {
                    subscribedYaraSources: true
                }
            })
            
            const sources = user.subscribedYaraSources
            
            return sources
        }
        
        catch(error) {
            throw error
        }
    }
    
    async listYaraSources() {
        try {
            const yara_sources = await this.prisma.yaraRuleSource.findMany()

            return yara_sources
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new BadRequestException(error.message)
            }
        }
    }
    
}
