import { Injectable, NotAcceptableException, NotFoundException, PreconditionFailedException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { File, YaraRule } from '@prisma/client';
import { resolve } from 'path';
import { spawn } from 'child_process';

@Injectable()
export class FileService {
    constructor(private prisma: PrismaService) {}
    
    private YARA_CLI_PATH = resolve(__dirname, "../../yara")
    private SSDEEP_CLI_PATH = resolve(__dirname, "../../resources/ssdeep-2.14.1")
    private FUZZY_HASHES_FILE = resolve(__dirname, "../../resources/malwareFuzzyHashes.txt")
    
    async addFileToUser(file: Express.Multer.File, email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            let rootProjectFolder = resolve(__dirname, '../../')
            let data = {
                storedName: file.filename,
                originalName: file.originalname,
                type: file.mimetype,
                length: file.size,
                location: `${rootProjectFolder}/${file.path}`,
                userId: user.id
            }
            
            const createdFile = await this.prisma.file.create({data})
            delete createdFile.location
            return createdFile
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotAcceptableException(error.message)
            }
        }
    }
    
    // list all files from user
    async getFilesFromUser(email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            
            const files = await this.prisma.file.findMany({ 
                where: {
                    userId: user.id
                },
                orderBy: {
                    createdAt: 'desc'
                },
            })
            
            files.forEach((file) => {
                delete file.location
            })
            
            return files
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message)
            }
        }
    }
    
    async analyzeFileWithSubscribedYaraSources(email: string, fileId: string) {
        const user = await this.prisma.user.findUnique({
            where: {
                email
            }
        });
        
        const file = await this.prisma.file.findUnique({
            where: {
                id: fileId,
            },
            include: {
                analysys: true
            }
        });
        
        if (!file || file.userId != user.id) {
            throw new NotFoundException("File not found");
        }
        
        let fileIsMalware = false;
        
        const subscribedYaraSources = await this.prisma.yaraRuleSourcesOnUsers.findMany({
            where: {
                userId: user.id,
            }
        });
        
        if (!subscribedYaraSources.length) {
            throw new PreconditionFailedException("User is not subscribed to any YARA Sources");
        }
        
        try {
            let analysis = [];
            
            for (const source of subscribedYaraSources) {
                const rulesWithSource = await this.prisma.yaraRuleSource.findMany({
                    select: {
                        name: true,
                        rules: true
                    },
                    where: {
                        id: source.sourceId
                    }
                });
                
                for (const current_source of rulesWithSource) {
                    const { name, rules } = current_source;
                    analysis.push({
                        source: name,
                        triggered_yara_rules: []
                    });
                    
                    for (const rule of rules) {
                        //if (rule.fileName !== "test.yar") { continue; }
                        let current_analysis = await this.runYaraRulesOnFileObject(rule, file);
                        if (current_analysis.detectionOccurred) {
                            analysis[analysis.length - 1].triggered_yara_rules.push(`${current_analysis.ruleName} - ${rule.fileName}`);
                        }
                    }
                }
            }
            
            const analysis_results = analysis.filter((obj) => obj.triggered_yara_rules.length > 0);

            let info: string[] = []

            
            analysis_results.forEach((item) => {
                item.triggered_yara_rules.forEach((triggeredRule) => {
                    info.push(`${item.source} - ${triggeredRule}`);
                });
            });

            //ISO 8601 
            const isoDateTime = new Date().toISOString();
            
            let updatedFile = await this.prisma.file.update({
                where: {
                    id: file.id
                },
                data: {
                    isAnalyzed: true,
                    lastAnalyzedAt: isoDateTime,
                    analysys: {
                        create: {
                            type: 'YARA',
                            info
                        }
                    }
                    
                    
                }
            });
            delete updatedFile.location
            
            return updatedFile
            
        } catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }

            throw error
        }
    }
    
    async analyzeFileWithSpecificSource(fileId: string, sourceId: string) {
        
    }
    
    async runYaraRulesOnFileObject(rule: YaraRule, file: File) : Promise<{ detectionOccurred: boolean; ruleName: string; }> {
        return new Promise<{ detectionOccurred: boolean; ruleName: string; }>((resolve, reject) => {
            let detectionOccurred = false;
            let ruleName = "";
            
            try {
                const ex = spawn(`${this.YARA_CLI_PATH}\\yara64.exe`, [rule.path, file.location]);
                
                ex.stdout.on("data", (data) => {
                    // console.log(`stdout: ${data}`);
                    ruleName = String(data).split(' ')[0];
                    detectionOccurred = true;
                });
                
                ex.stderr.on("data", data => {
                    //console.log(`stderr: ${data}`);
                });
                
                ex.on('error', (error) => {
                    //console.log(`error: ${error.message}`);
                    reject(error);
                });
                
                ex.on("close", code => {
                    // console.log(`child process exited with code ${code}`);
                    if (code !== 0) {
                        const msg = `Failed with code = ${code}`;
                        //console.log(msg);
                    }
                    resolve({ detectionOccurred, ruleName });
                });
                
            } catch (error) {
                console.log(error);
                reject(error);
            }
        });
    }
    
    async analysisHistoryFromUser(email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })

            const history = await this.prisma.analysis.findMany({
                where: {
                  file: {
                    userId: user.id,
                  },
                },
                include: {
                  file: {
                    select: {
                      originalName: true,
                    },
                  },
                },
                orderBy: {
                    updatedAt: 'desc'
                }
              });

              return history

        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotAcceptableException(error.message)
            }
        }
    }
    
    async analyzeFileWithFuzzyHashing(email: string, fileId: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            });
            
            const file = await this.prisma.file.findUnique({
                where: {
                    id: fileId,
                }
            });
            
            if (!file || file.userId != user.id) {
                throw new NotFoundException("File not found");
            }

            const { detectionOccurred, detections } = await this.runFuzzyHashingAnalysisOnFileObject(file)

            let triggeredAnalysis = file.triggeredAnalysis;

            for (const detection of detections) {
                triggeredAnalysis.push(`Fuzzy Hashing - ${detection}`)
            }

            //ISO 8601 
            const isoDateTime = new Date().toISOString();
            
            let updatedFile = await this.prisma.file.update({
                where: {
                    id: file.id
                },
                data: {
                    isAnalyzed: true,
                    isMalware: detectionOccurred,
                    triggeredAnalysis,
                    lastAnalyzedAt: isoDateTime
                    
                }
            });
            delete updatedFile.location
            
            return updatedFile

        }
        catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }

            throw error
        }
    }

    async runFuzzyHashingAnalysisOnFileObject(file: File) : Promise<{ detectionOccurred: boolean, detections: string[] }> {
        return new Promise<{ detectionOccurred: boolean, detections: string[] }>((resolve, reject) => {
            let detectionOccurred = false;
            let detections = []
            
            try {
                const ex = spawn(`${this.SSDEEP_CLI_PATH}\\ssdeep.exe`, ['-s', '-m', this.FUZZY_HASHES_FILE, file.location]);
                
                ex.stdout.on("data", (data) => {
                    // console.log(`stdout: ${data}`);
                    detections.push(String(data))
                    detectionOccurred = true;
                });
                
                ex.stderr.on("data", data => {
                    //console.log(`stderr: ${data}`);
                });
                
                ex.on('error', (error) => {
                    //console.log(`error: ${error.message}`);
                    reject(error);
                });
                
                ex.on("close", code => {
                    // console.log(`child process exited with code ${code}`);
                    if (code !== 0) {
                        const msg = `Failed with code = ${code}`;
                        //console.log(msg);
                    }
                    resolve({ detectionOccurred, detections });
                });
                
            } catch (error) {
                console.log(error);
                reject(error);
            }
        });
    }
}

