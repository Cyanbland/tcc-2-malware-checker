import { Injectable, NotAcceptableException, NotFoundException, PreconditionFailedException, UnprocessableEntityException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { AnalysisType, File, YaraRule } from '@prisma/client';
import { resolve } from 'path';
import { spawn } from 'child_process';
import { createHash } from 'crypto';
import { MalwareBazaar } from './malware_bazaar';

@Injectable()
export class FileService {
    constructor(private prisma: PrismaService, private malwareBazaar: MalwareBazaar) {}
    
    private YARA_CLI_PATH = resolve(__dirname, "../../yara")
    private SSDEEP_CLI_PATH = resolve(__dirname, "../../resources/ssdeep-2.14.1")
    private FUZZY_HASHES_FILE = resolve(__dirname, "../../resources/malwareFuzzyHashes.txt")
    private PE_IMPORTS_PATH = resolve(__dirname, "../../resources/pe_imports")
    private AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER = 0.2 // 20% bonus
    private AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER = 3
    private AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE = 10
    private AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE = 3
    private AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE: 3
    private IS_MALWARE_THRESHOLD = 60
    
    async addFileToUser(file: Express.Multer.File, email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            let rootProjectFolder = resolve(__dirname, '../../')
            let data = {
                storedName: file.filename,
                originalName: file.originalname,
                type: file.mimetype,
                length: file.size,
                location: `${rootProjectFolder}/${file.path}`,
                userId: user.id
            }
            
            const createdFile = await this.prisma.file.create({data})
            delete createdFile.location
            return createdFile
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotAcceptableException(error.message)
            }
        }
    }
    
    // list all files from user
    async getFilesFromUser(email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            
            const files = await this.prisma.file.findMany({ 
                where: {
                    userId: user.id
                },
                orderBy: {
                    createdAt: 'desc'
                },
            })
            
            files.forEach((file) => {
                delete file.location
            })
            
            return files
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message)
            }
        }
    }

    async analyzeFileWithImportHashing(email: string, fileId: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            });
            const file = await this.prisma.file.findUnique({
                where: {
                    id: fileId,
                }
            });

            if (!file || file.userId != user.id) {
                throw new NotFoundException("File not found");
            }
            
            const { imports } = await this.getImportsFromPeFile(file.location)

            let importStrs = []
            

            for (const imp in imports) {
                let impName = imp.substring(0, imp.lastIndexOf('.')).toLowerCase()
                imports[imp].map(item => importStrs.push(`${impName}.${String(item.split(" ")[0]).toLowerCase()}`))
            }
            
            const finalImportString = importStrs.join(',')

            const importHash = createHash('md5').update(finalImportString).digest('hex')
            console.log(importHash)

            try {
                const bazaarQueryResult = await this.malwareBazaar.queryImphash(importHash);
                console.log(bazaarQueryResult);
            
                if (bazaarQueryResult.query_status === 'no_results') {
                    return []
                }
                if (bazaarQueryResult.query_status === 'ok')  {
                    let detections = []

                    bazaarQueryResult.data.forEach(item => {
                        const signature = item.signature;
                        const fileName = item.file_name;
            
                        detections.push(`${signature} - ${fileName}`)
                    });

                    return detections
                }

                return []
            
            } catch (error) {
                // Handle errors if any
                console.error("Error occurred while querying imphash:", error);
            }

        }
        catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }
            
            if (error instanceof PreconditionFailedException) {
                throw new UnprocessableEntityException(error.message)
            }
            console.error(error)
        }
    }

    async getImportsFromPeFile(filePath: string) : Promise<{ imports: Object }> {
        return new Promise<{ imports: Object }>((resolve, reject) => {
            let importData = ''
            
            try {
                const ex = spawn(`python`, [`${this.PE_IMPORTS_PATH}\\main.py`, filePath]);
                
                ex.stdout.on("data", (data: Buffer) => {
                    importData += data.toString(); // Accumulate the received data
    
                    const trimmedData = importData.trim();
                    if (trimmedData === "File is not a Portable Executable") {
                        reject(new PreconditionFailedException("Can't run Import Hashing because file is not a Portable Executable."));
                        return;
                    }
    
                    try {
                        const parsedImports = JSON.parse(trimmedData);
                        resolve({ imports: parsedImports });
                    } catch (parseError) {
                        // JSON is not complete yet, continue receiving data
                    }
                });
                
                ex.stderr.on("data", data => {
                    //console.log(`stderr: ${data}`);
                });
                
                ex.on('error', (error) => {
                    //console.log(`error: ${error.message}`);
                    reject(error);
                });
                
                ex.on("close", code => {
                    // console.log(`child process exited with code ${code}`);
                    if (code !== 0) {
                        const msg = `Failed with code = ${code}`;
                        //console.log(msg);
                    }
                });
                
            } catch (error) {
                console.log(error);
                reject(error);
            }
        });
    }
    
    async analyzeFileWithSubscribedYaraSources(email: string, fileId: string) {
        const user = await this.prisma.user.findUnique({
            where: {
                email
            }
        });
        
        const file = await this.prisma.file.findUnique({
            where: {
                id: fileId,
            },
            include: {
                analysys: true
            }
        });
        
        if (!file || file.userId != user.id) {
            throw new NotFoundException("File not found");
        }
        
        const subscribedYaraSources = await this.prisma.yaraRuleSourcesOnUsers.findMany({
            where: {
                userId: user.id,
            }
        });
        
        if (!subscribedYaraSources.length) {
            throw new PreconditionFailedException("User is not subscribed to any YARA Sources");
        }
        
        try {
            let analysis = [];
            
            for (const source of subscribedYaraSources) {
                const rulesWithSource = await this.prisma.yaraRuleSource.findMany({
                    select: {
                        name: true,
                        rules: true
                    },
                    where: {
                        id: source.sourceId
                    }
                });
                
                for (const current_source of rulesWithSource) {
                    const { name, rules } = current_source;
                    analysis.push({
                        source: name,
                        triggered_yara_rules: []
                    });
                    
                    for (const rule of rules) {
                        //if (rule.fileName !== "test.yar") { continue; }
                        let current_analysis = await this.runYaraRulesOnFileObject(rule, file);
                        if (current_analysis.detectionOccurred) {
                            analysis[analysis.length - 1].triggered_yara_rules.push(`${current_analysis.ruleName} - ${rule.fileName}`);
                        }
                    }
                }
            }
            
            const analysis_results = analysis.filter((obj) => obj.triggered_yara_rules.length > 0);
            
            let info: string[] = []
            
            
            analysis_results.forEach((item) => {
                item.triggered_yara_rules.forEach((triggeredRule) => {
                    info.push(`${item.source} - ${triggeredRule}`);
                });
            });

            return info
            
        } catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }
            
            throw error
        }
    }
    
    async runYaraRulesOnFileObject(rule: YaraRule, file: File) : Promise<{ detectionOccurred: boolean; ruleName: string; }> {
        return new Promise<{ detectionOccurred: boolean; ruleName: string; }>((resolve, reject) => {
            let detectionOccurred = false;
            let ruleName = "";
            
            try {
                const ex = spawn(`${this.YARA_CLI_PATH}\\yara64.exe`, [rule.path, file.location]);
                
                ex.stdout.on("data", (data) => {
                    // console.log(`stdout: ${data}`);
                    ruleName = String(data).split(' ')[0];
                    detectionOccurred = true;
                });
                
                ex.stderr.on("data", data => {
                    //console.log(`stderr: ${data}`);
                });
                
                ex.on('error', (error) => {
                    //console.log(`error: ${error.message}`);
                    reject(error);
                });
                
                ex.on("close", code => {
                    // console.log(`child process exited with code ${code}`);
                    if (code !== 0) {
                        const msg = `Failed with code = ${code}`;
                        //console.log(msg);
                    }
                    resolve({ detectionOccurred, ruleName });
                });
                
            } catch (error) {
                console.log(error);
                reject(error);
            }
        });
    }
    
    async analysisHistoryFromUser(email: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            })
            
            // TODO NEED TO UPDATE BECAUSE INCLUDE FILE IS NOT NEEDED ANYMORE
            // const history = await this.prisma.analysis.findMany({
            //     where: {
            //         file: {
            //             userId: user.id,
            //         },
            //     },
            //     include: {
            //         file: {
            //             select: {
            //                 originalName: true,
            //                 isMalware: true,
            //                 malwareScore: true
            //             },
            //         },
            //     },
            //     orderBy: {
            //         updatedAt: 'desc'
            //     }
            // });

            const history = await this.prisma.analysis.findMany({
                where: {
                    file: {
                        userId: user.id,
                    },
                },
                include: {
                    file: {
                        select: {
                            originalName: true,
                        },
                    },
                },
                orderBy: {
                    updatedAt: 'desc'
                }
            });
            
            return history
            
        }
        catch(error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotAcceptableException(error.message)
            }
        }
    }
    
    async analyzeFileWithFuzzyHashing(email: string, fileId: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            });
            
            const file = await this.prisma.file.findUnique({
                where: {
                    id: fileId,
                }
            });
            
            if (!file || file.userId != user.id) {
                throw new NotFoundException("File not found");
            }
            
            const { detectionOccurred, detections } = await this.runFuzzyHashingAnalysisOnFileObject(file)
            
            // let triggeredAnalysis = file.triggeredAnalysis;
            
            // for (const detection of detections) {
            //     triggeredAnalysis.push(`Fuzzy Hashing - ${detection}`)
            // }

            return detections
            
        }
        catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }
            
            throw error
        }
    }
    
    async runFuzzyHashingAnalysisOnFileObject(file: File) : Promise<{ detectionOccurred: boolean, detections: string[] }> {
        return new Promise<{ detectionOccurred: boolean, detections: string[] }>((resolve, reject) => {
            let detectionOccurred = false;
            let detections = []
            
            try {
                const ex = spawn(`${this.SSDEEP_CLI_PATH}\\ssdeep.exe`, ['-s', '-m', this.FUZZY_HASHES_FILE, file.location]);
                
                ex.stdout.on("data", (data) => {
                    // console.log(`stdout: ${data}`);
                    detections.push(String(data))
                    detectionOccurred = true;
                });
                
                ex.stderr.on("data", data => {
                    //console.log(`stderr: ${data}`);
                });
                
                ex.on('error', (error) => {
                    //console.log(`error: ${error.message}`);
                    reject(error);
                });
                
                ex.on("close", async code => {
                    // console.log(`child process exited with code ${code}`);
                    if (code !== 0) {
                        const msg = `Failed with code = ${code}`;
                        //console.log(msg);
                    }

                    resolve({ detectionOccurred, detections });
                });
                
            } catch (error) {
                console.log(error);
                reject(error);
            }
        });
    }

    async analyzeFileWithNetworkSniffing(email: string, fileId: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            });
            const file = await this.prisma.file.findUnique({
                where: {
                    id: fileId,
                }
            });

            if (!file || file.userId != user.id) {
                throw new NotFoundException("File not found");
            }
            
            const agentData = await this.prisma.agentData.findUnique({
                where: {
                    fileId: file.id
                }
            })

            if (!agentData) {
                throw new PreconditionFailedException("There is no Network Sniffing data collected from an agent")
            }

            // parse IPs
            // parse URLs
            // process data

        }
        catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }
            
            if (error instanceof PreconditionFailedException) {
                throw new UnprocessableEntityException(error.message)
            }
            console.error(error)
        }
    }

    async calculateYaraRulesScore(yaraDetections: string[]) {
        if (yaraDetections.length === 0) {
            return 0
        }

        //format = SOURCE - RULE
        const sources = [] // getting all the different sources
        const rules = [] // getting all the detections

        yaraDetections.forEach(item => {
            let [source, rule] = item.split(' - ');
            let current_source = source.trim()
            if (!sources.includes(current_source)) {
                sources.push(current_source);
            }

            let current_rule = rule.trim() 
            rules.push(current_rule); // can be duplicate, so no need to check if includes
        });

        // calculates base score based on the amount of triggers, but limits at max score without multiplier 
        const maxBaseScore = 10 / (1 + this.AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER) // if it's 0.2, will return 8.33, which is the max base score
        let baseScore = 0

        // AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE - maxBaseScore
        // rules.length                       - X
        // X = (rules.length * maxBaseScore) / AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE
        if (rules.length < this.AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE) { // checks if the max score can already be reached
            baseScore = (rules.length * maxBaseScore) / this.AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE
        }
        else {
            baseScore = maxBaseScore
        }

        
        // boost score because there are multiple sources
        // Calculate bonus multiplier based on the number of different sources
        let multiplier = 1;
        
        // AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER - AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
        // X                                       - sources.length
        // X = (AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER * sources.length) / AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
        if (sources.length < this.AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER) {
            multiplier += (this.AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER * sources.length) / this.AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
        }
        else { // sources.length >= this.AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
            multiplier += this.AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER // reaches the maximum multiplier (1.2x) if is already maxed
        }
        
        return baseScore * multiplier
    }

    async calculateFuzzyHashingScore(fuzzyHashingDetections: string[]) {
        if (fuzzyHashingDetections.length === 0) {
            return 0
        }
        const maxScore = 10

        if (fuzzyHashingDetections.length > this.AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE) {
            return maxScore
        }

        // MaxScore - AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE
        // X - fuzzyHashingDetections.length
        // => X = (fuzzyHashingDetections.length * maxScore) / AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE

        const score = (fuzzyHashingDetections.length * maxScore) / this.AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE

        return score
    }

    async calculateImportHashingScore(importHashingDetections: string[]) {
        if (importHashingDetections.length === 0) {
            return 0
        }
        const maxScore = 10

        if (importHashingDetections.length > this.AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE) {
            return maxScore
        }

        // MaxScore - AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE
        // X - importHashingDetections.length
        // => X = (importHashingDetections.length * maxScore) / AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE

        const score = (importHashingDetections.length * maxScore) / this.AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE

        return score


    }
    
    async calculateFileMalwareScore(scores: number[]) {
        if (scores.length > 5 || scores.length == 0) {
            throw new Error("Scores length must range from 1 - 5")
        }
        
        let score = 0        
        score = (scores.reduce((total, current_score) => total += current_score, 0)) / scores.length
        // considerar no calculo apenas o que o usuário deseja (está habilitado)? Incluir fuzzy hashing como opção do usuário?

        return score
        
    }
    
    async deleteFileAndItsAnalysis(email: string, fileId: string) {
        // ALSO DELETES IT'S ANALYSES
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                }
            });
            
            const file = await this.prisma.file.findUnique({
                where: {
                    id: fileId,
                },
                include: {
                    analysys: true
                }
            });
            
            if (!file || file.userId != user.id) {
                throw new NotFoundException("File not found");
            }
            
            const deletedFile = await this.prisma.file.delete({
                where: {
                    id: file.id
                }
            })
            
            if (!deletedFile) {
                throw new NotFoundException("File ")
            }
            
            delete deletedFile.location
            return deletedFile
            
        } catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }
            
            throw error
        }
        
        
        
    }
    async runAnalysisWithEnabledConfigs(email: string, fileId: string) {
        try {
            const user = await this.prisma.user.findUnique({
                where: {
                    email
                },
                include: {
                    config: true
                }
            });
            
            const file = await this.prisma.file.findUnique({
                where: {
                    id: fileId,
                },
                include: {
                    analysys: true
                }
            });
            
            if (!file || file.userId != user.id) {
                throw new NotFoundException("File not found");
            }

            let analyses = []
            let scores = []
            const analysis_types = []

            const yaraRulesEnabled = user.config.enableYaraAnalysis
            const fuzzyHashingEnabled = user.config.enableFuzzyHashingAnalysis
            const importHashingEnabled = user.config.enableImportHashingAnalysis
            const networkSniffingEnabled = user.config.enableNetworkSniffingAnalysis
            const ransomwareDetectionEnabled = user.config.enableRansomwareDetectionAnalysis

            if (!yaraRulesEnabled && !fuzzyHashingEnabled && !importHashingEnabled && !networkSniffingEnabled && !ransomwareDetectionEnabled) {
                throw new PreconditionFailedException("No analyses configured. Please select at least one analysis to be used.")
            }

            // runs first because checks if file is a PE
            if (importHashingEnabled) {
                try {
                    const importHashingAnalysis = await this.analyzeFileWithImportHashing(email, fileId)
                    const importHashingScore = await this.calculateImportHashingScore(importHashingAnalysis)
                    analyses.push(importHashingAnalysis)
                    scores.push(importHashingScore)
                    analysis_types.push(AnalysisType.IMPORTHASH)
                }
                catch (error) {
                    throw new UnprocessableEntityException(error.message)
                }
            }

            if (networkSniffingEnabled) {
                try {
                    const networkSniffingAnalysis = await this.analyzeFileWithNetworkSniffing(email, fileId)
                }
                catch (error) {
                    throw new PreconditionFailedException(error.message)
                }
            }

            if (yaraRulesEnabled) {
                try {
                    const yaraRuleAnalysis = await this.analyzeFileWithSubscribedYaraSources(email, fileId)
                    const yaraMalwareScore = await this.calculateYaraRulesScore(yaraRuleAnalysis)
                    
                    analyses.push(yaraRuleAnalysis)
                    scores.push(yaraMalwareScore)
                    analysis_types.push(AnalysisType.YARA)
                }
                catch (error) {
                    throw new UnprocessableEntityException(error.message)
                }
            }

            if (fuzzyHashingEnabled) {
                try{
                    const fuzzyHashingAnalysis = await this.analyzeFileWithFuzzyHashing(email, fileId)
                    const fuzzyHashingScore = await this.calculateFuzzyHashingScore(fuzzyHashingAnalysis)
                    analyses.push(fuzzyHashingAnalysis)
                    scores.push(fuzzyHashingScore)
                    analysis_types.push(AnalysisType.FUZZYHASH)
                }
                catch (error) {
                    throw new UnprocessableEntityException(error.message)
                }
            }



            if (ransomwareDetectionEnabled) {

            }

            console.log(scores)
            const score = await this.calculateFileMalwareScore(scores)
                    
            const isMalware = (score >= this.IS_MALWARE_THRESHOLD)

            //ISO 8601 
            const isoDateTime = new Date().toISOString();

            const analysis = await this.prisma.analysis.create({
                data: {
                    fileId,
                    isMalware,
                    malwareScore: score,
                    types: analysis_types
                }
            })
        
            let updatedFile = await this.prisma.file.update({
                where: {
                    id: file.id
                },
                data: {
                    isAnalyzed: true,
                    lastAnalyzedAt: isoDateTime,
                    malwareScore: score,
                    isMalware
                }
            });

            delete updatedFile.location

            return updatedFile

        } catch (error) {
            if (error instanceof PrismaClientKnownRequestError) {
                throw new NotFoundException(error.message);
            }

            throw error;
        }
    }
}

