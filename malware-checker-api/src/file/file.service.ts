import { Injectable, NotAcceptableException, NotFoundException, PreconditionFailedException, UnprocessableEntityException } from '@nestjs/common'
import { PrismaService } from '../prisma/prisma.service'
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library'
import { AnalysisType, File, YaraRule } from '@prisma/client'
import { resolve } from 'path'
import { spawn } from 'child_process'
import { createHash } from 'crypto'
import { MalwareBazaar } from './malware_bazaar'
import { UrlHaus } from '../blocklist/urlhaus'

@Injectable()
export class FileService {
	constructor(private prisma: PrismaService, private malwareBazaar: MalwareBazaar, private urlhaus: UrlHaus) {}
	
	private YARA_CLI_PATH = resolve(__dirname, "../../yara")
	private SSDEEP_CLI_PATH = resolve(__dirname, "../../resources/ssdeep-2.14.1")
	private FUZZY_HASHES_FILE = resolve(__dirname, "../../resources/malwareFuzzyHashes.txt")
	private PE_IMPORTS_PATH = resolve(__dirname, "../../resources/pe_imports")
	private AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER = 0.2 // 20% bonus
	private AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER = 3
	private AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE = 10
	private AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE = 3
	private AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE = 3
	private AMOUT_OF_NETWORK_SNIFFING_IPS_FOR_MAX_SCORE = 3
	private AMOUT_OF_NETWORK_SNIFFING_URLS_FOR_MAX_SCORE = 1 // lower because of HTTPS
	private AMOUNT_OF_RENAME_OPERATIONS_IN_10_SECONDS_FOR_MAX_SCORE = 100 // Lockbit = 285 files / second 
	private NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO = 0.7 // 70% of the score is based on IPs and 30% on URLs

	private IS_MALWARE_THRESHOLD = 6
	
	async addFileToUser(file: Express.Multer.File, email: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			let rootProjectFolder = resolve(__dirname, '../../')
			let data = {
				storedName: file.filename,
				originalName: file.originalname,
				type: file.mimetype,
				length: file.size,
				location: `${rootProjectFolder}/${file.path}`,
				userId: user.id
			}
			
			const createdFile = await this.prisma.file.create({data})
			delete createdFile.location
			return createdFile
		}
		catch(error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotAcceptableException(error.message)
			}
		}
	}
	
	// list all files from user
	async getFilesFromUser(email: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			
			const files = await this.prisma.file.findMany({ 
				where: {
					userId: user.id
				},
				orderBy: {
					createdAt: 'desc'
				},
			})
			
			files.forEach((file) => {
				delete file.location
			})
			
			return files
		}
		catch(error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
		}
	}

	async analyzeFileWithImportHashing(email: string, fileId: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			const file = await this.prisma.file.findUnique({
				where: {
					id: fileId,
				}
			})

			if (!file || file.userId != user.id) {
				throw new NotFoundException("File not found")
			}
			
			const { imports } = await this.getImportsFromPeFile(file.location)

			let importStrs = []
			

			for (const imp in imports) {
				let impName = imp.substring(0, imp.lastIndexOf('.')).toLowerCase()
				imports[imp].map(item => importStrs.push(`${impName}.${String(item.split(" ")[0]).toLowerCase()}`))
			}
			
			const finalImportString = importStrs.join(',')

			const importHash = createHash('md5').update(finalImportString).digest('hex')
			console.log(importHash)

			try {
				const bazaarQueryResult = await this.malwareBazaar.queryImphash(importHash)
				console.log(bazaarQueryResult)
			
				if (bazaarQueryResult.query_status === 'no_results') {
					return []
				}
				if (bazaarQueryResult.query_status === 'ok')  {
					let detections = []

					bazaarQueryResult.data.forEach(item => {
						const signature = item.signature
						const fileName = item.file_name
			
						detections.push(`${signature} - ${fileName}`)
					})

					return detections
				}

				return []
			
			} catch (error) {
				// Handle errors if any
				console.error("Error occurred while querying imphash:", error)
			}

		}
		catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			if (error instanceof PreconditionFailedException) {
				throw new UnprocessableEntityException(error.message)
			}
			console.error(error)
		}
	}

	async getImportsFromPeFile(filePath: string) : Promise<{ imports: Object }> {
		return new Promise<{ imports: Object }>((resolve, reject) => {
			let importData = ''
			
			try {
				const ex = spawn(`python`, [`${this.PE_IMPORTS_PATH}\\main.py`, filePath])
				
				ex.stdout.on("data", (data: Buffer) => {
					importData += data.toString() // Accumulate the received data
	
					const trimmedData = importData.trim()
					if (trimmedData === "File is not a Portable Executable") {
						reject(new PreconditionFailedException("Can't run Import Hashing because file is not a Portable Executable."))
						return
					}
	
					try {
						const parsedImports = JSON.parse(trimmedData)
						resolve({ imports: parsedImports })
					} catch (parseError) {
						// JSON is not complete yet, continue receiving data
					}
				})
				
				ex.stderr.on("data", data => {
					//console.log(`stderr: ${data}`)
				})
				
				ex.on('error', (error) => {
					//console.log(`error: ${error.message}`)
					reject(error)
				})
				
				ex.on("close", code => {
					// console.log(`child process exited with code ${code}`)
					if (code !== 0) {
						const msg = `Failed with code = ${code}`
						//console.log(msg)
					}
				})
				
			} catch (error) {
				console.log(error)
				reject(error)
			}
		})
	}
	
	async analyzeFileWithSubscribedYaraSources(email: string, fileId: string) {
		const user = await this.prisma.user.findUnique({
			where: {
				email
			}
		})
		
		const file = await this.prisma.file.findUnique({
			where: {
				id: fileId,
			},
			include: {
				analysys: true
			}
		})
		
		if (!file || file.userId != user.id) {
			throw new NotFoundException("File not found")
		}
		
		const subscribedYaraSources = await this.prisma.yaraRuleSourcesOnUsers.findMany({
			where: {
				userId: user.id,
			}
		})
		
		if (!subscribedYaraSources.length) {
			throw new PreconditionFailedException("User is not subscribed to any YARA Sources")
		}
		
		try {
			let analyses = []
			
			for (const source of subscribedYaraSources) {
				const rulesWithSource = await this.prisma.yaraRuleSource.findMany({
					select: {
						name: true,
						rules: true
					},
					where: {
						id: source.sourceId
					}
				})
				
				for (const current_source of rulesWithSource) {
					const { name, rules } = current_source
					analyses.push({
						source: name,
						triggered_yara_rules: []
					})
					
					for (const rule of rules) {
						//if (rule.fileName !== "test.yar") { continue }
						let current_analysis = await this.runYaraRulesOnFileObject(rule, file)
						if (current_analysis.detectionOccurred) {
							analyses[analyses.length - 1].triggered_yara_rules.push(`${current_analysis.ruleName} - ${rule.fileName}`)
						}
					}
				}
			}
			
			const analyses_results = analyses.filter((obj) => obj.triggered_yara_rules.length > 0)
			
			let info: string[] = []
			
			
			analyses_results.forEach((item) => {
				item.triggered_yara_rules.forEach((triggeredRule) => {
					info.push(`${item.source} - ${triggeredRule}`)
				})
			})

			return info
			
		} catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			throw error
		}
	}
	
	async runYaraRulesOnFileObject(rule: YaraRule, file: File) : Promise<{ detectionOccurred: boolean; ruleName: string }> {
		return new Promise<{ detectionOccurred: boolean; ruleName: string }>((resolve, reject) => {
			let detectionOccurred = false
			let ruleName = ""
			
			try {
				const ex = spawn(`${this.YARA_CLI_PATH}\\yara64.exe`, [rule.path, file.location])
				
				ex.stdout.on("data", (data) => {
					// console.log(`stdout: ${data}`)
					ruleName = String(data).split(' ')[0]
					detectionOccurred = true
				})
				
				ex.stderr.on("data", data => {
					//console.log(`stderr: ${data}`)
				})
				
				ex.on('error', (error) => {
					//console.log(`error: ${error.message}`)
					reject(error)
				})
				
				ex.on("close", code => {
					// console.log(`child process exited with code ${code}`)
					if (code !== 0) {
						const msg = `Failed with code = ${code}`
						//console.log(msg)
					}
					resolve({ detectionOccurred, ruleName })
				})
				
			} catch (error) {
				console.log(error)
				reject(error)
			}
		})
	}
	
	async analysisHistoryFromUser(email: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			
			// TODO NEED TO UPDATE BECAUSE INCLUDE FILE IS NOT NEEDED ANYMORE
			// const history = await this.prisma.analysis.findMany({
			//     where: {
			//         file: {
			//             userId: user.id,
			//         },
			//     },
			//     include: {
			//         file: {
			//             select: {
			//                 originalName: true,
			//                 isMalware: true,
			//                 malwareScore: true
			//             },
			//         },
			//     },
			//     orderBy: {
			//         updatedAt: 'desc'
			//     }
			// })

			const history = await this.prisma.analysis.findMany({
				where: {
					file: {
						userId: user.id,
					},
				},
				include: {
					file: {
						select: {
							originalName: true,
						},
					},
				},
				orderBy: {
					updatedAt: 'desc'
				}
			})
			
			return history
			
		}
		catch(error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotAcceptableException(error.message)
			}
		}
	}
	
	async analyzeFileWithFuzzyHashing(email: string, fileId: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			
			const file = await this.prisma.file.findUnique({
				where: {
					id: fileId,
				}
			})
			
			if (!file || file.userId != user.id) {
				throw new NotFoundException("File not found")
			}
			
			const { detectionOccurred, detections } = await this.runFuzzyHashingAnalysisOnFileObject(file)
			
			// let triggeredAnalysis = file.triggeredAnalysis
			
			// for (const detection of detections) {
			//     triggeredAnalysis.push(`Fuzzy Hashing - ${detection}`)
			// }

			return detections
			
		}
		catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			throw error
		}
	}
	
	async runFuzzyHashingAnalysisOnFileObject(file: File) : Promise<{ detectionOccurred: boolean, detections: string[] }> {
		return new Promise<{ detectionOccurred: boolean, detections: string[] }>((resolve, reject) => {
			let detectionOccurred = false
			let detections = []
			
			try {
				const ex = spawn(`${this.SSDEEP_CLI_PATH}\\ssdeep.exe`, ['-s', '-m', this.FUZZY_HASHES_FILE, file.location])
				
				ex.stdout.on("data", (data) => {
					// console.log(`stdout: ${data}`)
					detections.push(String(data))
					detectionOccurred = true
				})
				
				ex.stderr.on("data", data => {
					//console.log(`stderr: ${data}`)
				})
				
				ex.on('error', (error) => {
					//console.log(`error: ${error.message}`)
					reject(error)
				})
				
				ex.on("close", async code => {
					// console.log(`child process exited with code ${code}`)
					if (code !== 0) {
						const msg = `Failed with code = ${code}`
						//console.log(msg)
					}

					resolve({ detectionOccurred, detections })
				})
				
			} catch (error) {
				console.log(error)
				reject(error)
			}
		})
	}

	async analyzeFileWithNetworkSniffing(email: string, fileId: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			const file = await this.prisma.file.findUnique({
				where: {
					id: fileId,
				}
			})

			if (!file || file.userId != user.id) {
				throw new NotFoundException("File not found")
			}
			
			const agentData = await this.prisma.agentData.findUnique({
				where: {
					fileId: file.id
				}
			})

			if (!agentData) {
				throw new PreconditionFailedException("There is no Network Sniffing data collected from an agent")
			}

			const ips = agentData.networkSniffingIPs
			const detectedMaliciousIps = await this.checkIfIpsInBlocklist(ips)

			const urls = agentData.networkSniffingURLs
			const detectedMaliciousURLs = await this.checkIfUrlsInBlocklist(urls)
			
			return {
				detectedMaliciousIps,
				detectedMaliciousURLs
			}

		}
		catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			if (error instanceof PreconditionFailedException) {
				throw new UnprocessableEntityException(error.message)
			}
			console.error(error)
		}
	}

	async checkIfIpsInBlocklist(ips: string[]) {
		try {
			let detectedMaliciousIps: string[] = []

			const ipList = new Set((await this.prisma.iPBlockList.findFirst()).ips)

			for (const ip of ips) {
				if (ipList.has(ip)) {
					detectedMaliciousIps.push(ip)
				}
			}

			return detectedMaliciousIps

		}
		catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			if (error instanceof PreconditionFailedException) {
				throw new UnprocessableEntityException(error.message)
			}
			console.error(error)
		}
	}

	async checkIfUrlsInBlocklist(urls: string[]) {
		try {
			const detectedMaliciousURLs: string[] = []

			for (const url of urls) {
				const urlhausQueryResult = await this.urlhaus.queryUrl(url)
				console.log(urlhausQueryResult)

				if (urlhausQueryResult.query_status === 'no_results') {
					continue
				}
				if (urlhausQueryResult.query_status === 'ok')  {
					if (urlhausQueryResult.url_status === 'online' || urlhausQueryResult.url_status === 'offline') { // The malware URL is active (online) and currently serving a payload || The malware URL is inadctive (offline) and serving no payload
						detectedMaliciousURLs.push(url)
					}
				}
			}

			return detectedMaliciousURLs
		
		} catch (error) {
			console.error("Error occurred while querying url:", error)
		}
	}

	calculateNetworkSniffingScore(detectedMaliciousIps: string[], detectedMaliciousURLs: string[]) {
		const maxScore = 10
	
		// NO IPs AND NO URLs
		if (detectedMaliciousIps.length === 0 && detectedMaliciousURLs.length === 0) {
			return 0
		}
		
		// NO IPs BUT URL, so we can consider that the NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO can be used to represent the whole score. In this case, URLs are more valuable than IPs because they are more rare to get using HTTPS
		if (detectedMaliciousIps.length === 0) {
			// already reached max possible URL score
			if (detectedMaliciousURLs.length > this.AMOUT_OF_NETWORK_SNIFFING_URLS_FOR_MAX_SCORE) {
				return maxScore * this.NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO
			}

			// calculate score
			// maxScore - AMOUT_OF_NETWORK_SNIFFING_URLS_FOR_MAX_SCORE
			//   X      - detectedMaliciousURLs.length
			// We then multiply by NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO since we can't get max score without both informations
			return ((maxScore * detectedMaliciousURLs.length) / this.AMOUT_OF_NETWORK_SNIFFING_URLS_FOR_MAX_SCORE) * this.NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO
		}

		// IPs but no URL
		// by now, we can confirm that there are IPs, so no need to check
		if (detectedMaliciousURLs.length === 0) {
			// already reached max possible IP score
			if (detectedMaliciousIps.length > this.AMOUT_OF_NETWORK_SNIFFING_IPS_FOR_MAX_SCORE) {
				return maxScore * this.NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO
			}

			// calculate score
			// maxScore - AMOUT_OF_NETWORK_SNIFFING_IPS_FOR_MAX_SCORE
			//   X      - detectedMaliciousIPs.length
			return ((maxScore * detectedMaliciousIps.length) / this.AMOUT_OF_NETWORK_SNIFFING_IPS_FOR_MAX_SCORE) * this.NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO
		}

		// only reaches this code if there are IPs and URLs
		// If there are both informations, we need to prioritize URLs since they are more rare to get because of HTTPs
		const maxIpScore = maxScore * (1 - this.NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO)
		const maxUrlScore = maxScore * this.NETWORK_SNIFFING_IPS_TO_URL_SCORE_RATIO
		
		// maxIpScore - AMOUT_OF_NETWORK_SNIFFING_IPS_FOR_MAX_SCORE
		//   X      - detectedMaliciousIPs.length
		let ipScore = (maxIpScore * detectedMaliciousIps.length) / this.AMOUT_OF_NETWORK_SNIFFING_IPS_FOR_MAX_SCORE
		if (ipScore > maxIpScore) {
			ipScore = maxIpScore
		} 

		// maxUrlScore - AMOUT_OF_NETWORK_SNIFFING_URLS_FOR_MAX_SCORE
		//   X      - detectedMaliciousURLs.length
		let urlScore = (maxUrlScore * detectedMaliciousURLs.length) / this.AMOUT_OF_NETWORK_SNIFFING_URLS_FOR_MAX_SCORE
		if (urlScore > maxUrlScore) {
			urlScore = maxUrlScore
		}

		return ipScore + urlScore
	}

	async analyzeFileWithRansomwareDetection(email: string, fileId: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			const file = await this.prisma.file.findUnique({
				where: {
					id: fileId,
				}
			})

			if (!file || file.userId != user.id) {
				throw new NotFoundException("File not found")
			}
			
			const agentData = await this.prisma.agentData.findUnique({
				where: {
					fileId: file.id
				}
			})

			if (!agentData) {
				throw new PreconditionFailedException("There is no Ransomware Detection data collected from an agent")
			}

			const detections = agentData.ransomwareDetectionData

			// separate in 10 second group
			const detectionGroups = {}

			detections.forEach(detection => {
				const timestamp = detection.match(/^(\d{2}:\d{2}:\d{2}\.\d{3})/)
				if (timestamp) {
					const [hours, minutes, seconds, milliseconds] = timestamp[0].split(/[:.]/).map(Number)

					const totalSeconds = (hours * 3600) + (minutes * 60) + seconds
					const intervalStart = Math.floor(totalSeconds / 10) * 10

					// format "hh:mm:ss"
					const date = new Date(intervalStart * 1000)
					const intervalKey = date.toISOString().slice(11, 19)

					if (!detectionGroups[intervalKey]) {
						detectionGroups[intervalKey] = []
					}

					detectionGroups[intervalKey].push(detection)
				}
			})

			return detectionGroups
		}
		catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			if (error instanceof PreconditionFailedException) {
				throw new UnprocessableEntityException(error.message)
			}
			console.error(error)
		}
	}

	calculateRansomwareDetectionScore(groupedRenameOperations: object) {
		const maxBaseScore = 10

		// PROCESS 10 SECOND OPERATION GROUPS
		// get the group with the most amount of rename operations
		let mostAmountOfDetections = 0
		let maxIntervalKey = ''

		for (const [intervalKey, logs] of Object.entries(groupedRenameOperations)) {
			if (logs.length > mostAmountOfDetections) {
				mostAmountOfDetections = logs.length
				maxIntervalKey = intervalKey
			}
		}

		// this.AMOUNT_OF_RENAME_OPERATIONS_IN_10_SECONDS_FOR_MAX_SCORE -            maxBaseScore 
		//                       X                                      -            mostAmountOfDetections
		// X = (mostAmountOfDetections * this.AMOUNT_OF_RENAME_OPERATIONS_IN_10_SECONDS_FOR_MAX_SCORE) / maxBaseScore

		if (mostAmountOfDetections >= this.AMOUNT_OF_RENAME_OPERATIONS_IN_10_SECONDS_FOR_MAX_SCORE) {
			return maxBaseScore
		}
		return (mostAmountOfDetections * this.AMOUNT_OF_RENAME_OPERATIONS_IN_10_SECONDS_FOR_MAX_SCORE) / maxBaseScore
	}
	
	calculateYaraRulesScore(yaraDetections: string[]) {
		if (yaraDetections.length === 0) {
			return 0
		}

		//format = SOURCE - RULE
		const sources = [] // getting all the different sources
		const rules = [] // getting all the detections

		yaraDetections.forEach(item => {
			let [source, rule] = item.split(' - ')
			let current_source = source.trim()
			if (!sources.includes(current_source)) {
				sources.push(current_source)
			}

			let current_rule = rule.trim() 
			rules.push(current_rule) // can be duplicate, so no need to check if includes
		})

		// calculates base score based on the amount of triggers, but limits at max score without multiplier 
		const maxBaseScore = 10 / (1 + this.AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER) // if it's 0.2, will return 8.33, which is the max base score
		let baseScore = 0

		// AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE - maxBaseScore
		// rules.length                       - X
		// X = (rules.length * maxBaseScore) / AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE
		if (rules.length < this.AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE) { // checks if the max score can already be reached
			baseScore = (rules.length * maxBaseScore) / this.AMOUNT_OF_YARA_RULES_FOR_MAX_SCORE
		}
		else {
			baseScore = maxBaseScore
		}

		// boost score because there are multiple sources
		// Calculate bonus multiplier based on the number of different sources
		let multiplier = 1
		
		// AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER - AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
		// X                                       - sources.length
		// X = (AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER * sources.length) / AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
		if (sources.length < this.AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER) {
			multiplier += (this.AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER * sources.length) / this.AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
		}
		else { // sources.length >= this.AMOUNT_OF_YARA_SOURCES_FOR_MAX_MULTIPLIER
			multiplier += this.AMOUNT_OF_YARA_SOURCES_SCORE_MULTIPLIER // reaches the maximum multiplier (1.2x) if is already maxed
		}
		
		return baseScore * multiplier
	}

	calculateFuzzyHashingScore(fuzzyHashingDetections: string[]) {
		if (fuzzyHashingDetections.length === 0) {
			return 0
		}
		const maxScore = 10

		if (fuzzyHashingDetections.length > this.AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE) {
			return maxScore
		}

		// MaxScore - AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE
		// X - fuzzyHashingDetections.length
		// => X = (fuzzyHashingDetections.length * maxScore) / AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE

		const score = (fuzzyHashingDetections.length * maxScore) / this.AMOUT_OF_FUZZY_HASHING_DETECTIONS_FOR_MAX_SCORE

		return score
	}

	calculateImportHashingScore(importHashingDetections: string[]) {
		if (importHashingDetections.length === 0) {
			return 0
		}
		const maxScore = 10

		if (importHashingDetections.length > this.AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE) {
			return maxScore
		}

		// MaxScore - AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE
		// X - importHashingDetections.length
		// => X = (importHashingDetections.length * maxScore) / AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE

		const score = (importHashingDetections.length * maxScore) / this.AMOUT_OF_IMPORT_HASHING_DETECTIONS_FOR_MAX_SCORE

		return score


	}
	
	async calculateFileMalwareScore(scores: number[]) {
		if (scores.length > 5 || scores.length == 0) {
			throw new Error("Scores length must range from 1 - 5")
		}
		
		let score = 0        
		score = (scores.reduce((total, current_score) => total += current_score, 0)) / scores.length
		// considerar no calculo apenas o que o usuário deseja (está habilitado)? Incluir fuzzy hashing como opção do usuário?

		return score
		
	}
	
	async deleteFileAndItsAnalysis(email: string, fileId: string) {
		// ALSO DELETES IT'S ANALYSES
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				}
			})
			
			const file = await this.prisma.file.findUnique({
				where: {
					id: fileId,
				},
				include: {
					analysys: true
				}
			})
			
			if (!file || file.userId != user.id) {
				throw new NotFoundException("File not found")
			}
			
			const deletedFile = await this.prisma.file.delete({
				where: {
					id: file.id
				}
			})
			
			if (!deletedFile) {
				throw new NotFoundException("File ")
			}
			
			delete deletedFile.location
			return deletedFile
			
		} catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}
			
			throw error
		}
	}
	async runAnalysisWithEnabledConfigs(email: string, fileId: string) {
		try {
			const user = await this.prisma.user.findUnique({
				where: {
					email
				},
				include: {
					config: true
				}
			})
			
			const file = await this.prisma.file.findUnique({
				where: {
					id: fileId,
				},
				include: {
					analysys: true
				}
			})
			
			if (!file || file.userId != user.id) {
				throw new NotFoundException("File not found")
			}

			let analyses = []
			let scores = []
			let analysis_types = []

			const yaraRulesEnabled = user.config.enableYaraAnalysis
			const fuzzyHashingEnabled = user.config.enableFuzzyHashingAnalysis
			const importHashingEnabled = user.config.enableImportHashingAnalysis
			const networkSniffingEnabled = user.config.enableNetworkSniffingAnalysis
			const ransomwareDetectionEnabled = user.config.enableRansomwareDetectionAnalysis

			if (!yaraRulesEnabled && !fuzzyHashingEnabled && !importHashingEnabled && !networkSniffingEnabled && !ransomwareDetectionEnabled) {
				throw new PreconditionFailedException("No analyses configured. Please select at least one analysis to be used.")
			}

			// runs first because checks if file is a PE
			if (importHashingEnabled) {
				try {
					const importHashingAnalysis = await this.analyzeFileWithImportHashing(email, fileId)
					const importHashingScore = await this.calculateImportHashingScore(importHashingAnalysis)
					analyses.push(importHashingAnalysis)
					scores.push(importHashingScore)
					analysis_types.push(AnalysisType.IMPORTHASH)
				}
				catch (error) {
					throw new UnprocessableEntityException(error.message)
				}
			}

			// checks if there is analysis data
			if (networkSniffingEnabled) {
				try {
					const { detectedMaliciousIps, detectedMaliciousURLs } = await this.analyzeFileWithNetworkSniffing(email, fileId)
					const networkSniffingScore = this.calculateNetworkSniffingScore(detectedMaliciousIps, detectedMaliciousURLs)
					analyses.push(detectedMaliciousIps.concat(detectedMaliciousURLs)) // join both arrays
					scores.push(networkSniffingScore)
					analysis_types.push(AnalysisType.NETWORKSNIFFING)
				}
				catch (error) {
					throw new PreconditionFailedException(error.message)
				}
			}

			if (yaraRulesEnabled) {
				try {
					const yaraRuleAnalysis = await this.analyzeFileWithSubscribedYaraSources(email, fileId)
					const yaraMalwareScore = this.calculateYaraRulesScore(yaraRuleAnalysis)
					
					analyses.push(yaraRuleAnalysis)
					scores.push(yaraMalwareScore)
					analysis_types.push(AnalysisType.YARA)
				}
				catch (error) {
					throw new UnprocessableEntityException(error.message)
				}
			}

			if (fuzzyHashingEnabled) {
				try {
					const fuzzyHashingAnalysis = await this.analyzeFileWithFuzzyHashing(email, fileId)
					const fuzzyHashingScore = this.calculateFuzzyHashingScore(fuzzyHashingAnalysis)
					analyses.push(fuzzyHashingAnalysis)
					scores.push(fuzzyHashingScore)
					analysis_types.push(AnalysisType.FUZZYHASH)
				}
				catch (error) {
					throw new UnprocessableEntityException(error.message)
				}
			}

			if (ransomwareDetectionEnabled) {
				try {
					const ransomwareDetectionAnalysis = await this.analyzeFileWithRansomwareDetection(email, fileId)
					const ransomwareDetectionScore = this.calculateRansomwareDetectionScore(ransomwareDetectionAnalysis)
					analyses.push(ransomwareDetectionAnalysis)
					scores.push(ransomwareDetectionScore)
					analysis_types.push(AnalysisType.RANSOMWAREDETECTION)
				}
				catch (error) {
					throw new UnprocessableEntityException(error.message)
				}
			}

			console.log(scores)
			const score = await this.calculateFileMalwareScore(scores)
					
			const isMalware = (score >= this.IS_MALWARE_THRESHOLD)

			//ISO 8601 
			const isoDateTime = new Date().toISOString()

			const analysis = await this.prisma.analysis.create({
				data: {
					fileId,
					isMalware,
					malwareScore: score,
					types: analysis_types
				}
			})
		
			let updatedFile = await this.prisma.file.update({
				where: {
					id: file.id
				},
				data: {
					isAnalyzed: true,
					lastAnalyzedAt: isoDateTime,
					malwareScore: score,
					isMalware
				}
			})

			delete updatedFile.location

			return updatedFile

		} catch (error) {
			if (error instanceof PrismaClientKnownRequestError) {
				throw new NotFoundException(error.message)
			}

			throw error
		}
	}
}

